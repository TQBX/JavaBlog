# Java：线程的生命周期

关于线程的生命周期，网上书上说法不一，难以统一，但不管是哪一种，线程从创建到消亡不外乎如下：

![1WKCQK.png](https://s2.ax1x.com/2020/02/08/1WKCQK.png)


## 新建状态
即用**new关键字**新建一个线程，这个线程就处于**新建状态**。
## 就绪状态
当线程对象调用了`start()`方法之后，线程处于**就绪状态**，就绪意味着该线程**可以执行**，但具体啥时候执行将取决于JVM里线程调度器的调度。

> It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution.

- 不允许对一个线程多次使用start。

- 线程执行完成之后，不能试图用start将其唤醒。


## 运行状态
处于就绪状态的线程获得了CPU之后，**真正开始执行run()方法的线程执行体时**，意味着该线程就已经处于**运行状态**。需要注意的是，**对于单处理器，一个时刻只能有一个线程处于运行状态。**
对于抢占式策略的系统来说，系统会给每个线程一小段时间处理各自的任务。时间用完之后，系统负责夺回线程占用的资源。下一段时间里，系统会根据一定规则，再次进行调度。

**运行状态转变为就绪状态**的情形：
- 线程失去处理器资源。线程不一定完整执行的，执行到一半，说不定就被别的线程抢走了。
- 线程调用yield()，暂时暂停当前线程，让系统的线程调度器重新调度一次，它自己完全有可能再次运行。

yield方法的官方解释：
> A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint. 

提示调度程序，当前线程愿意放弃当前对处理器的使用。这时，**当前线程将会被置为就绪状态**，和其他线程一样等待调度，这时候根据不同**优先级**决定的**概率**，当前线程完全有可能再次抢到处理器资源。
## 阻塞状态
处于**阻塞状态**的线程将会放弃所占用的资源，这时其他线程将会获得执行机会，同样地，将要执行的线程取决于JVM调度。

导致线程阻塞的几种情况：

- 线程调用`sleep()`方法，阻塞一段时间。
- 线程调用**阻塞式IO**方法，方法返回之前，线程会被阻塞。
- 试图取得其他线程正持有的同步监视器。
- 处于**等待唤醒**状态的线程会阻塞。

sleep和yield的不同之处：

- sleep()方法会**使线程转入阻塞状态**，时间到了之后才会转入就绪状态。而yield()方法不会将线程转入阻塞状态，而是强制线程进入就绪状态。
- 使用sleep()方法**需要处理异常**，而yield()不用。

## 消亡状态
即**线程的终止**，表示线程已经执行完毕。前面已经说了，已经消亡的线程不能通过start再次唤醒。

- run()和call()线程执行体中顺利执行完毕，**线程正常终止**。
- 线程抛出一个没有捕获的Exception或Error。


需要注意的是：主线成和子线程互不影响，子线程并不会因为主线程结束就结束。


参考资料：《JAVA并发编程实践》、《疯狂Java讲义》


## 新建状态
即用**new关键字**新建一个线程，这个线程就处于**新建状态**。
## 就绪状态
当线程对象调用了`start()`方法之后，线程处于**就绪状态**，就绪意味着该线程**可以执行**，但具体啥时候执行将取决于JVM里线程调度器的调度。

> It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution.

- 不允许对一个线程多次使用start。

- 线程执行完成之后，不能试图用start将其唤醒。


## 运行状态
处于就绪状态的线程获得了CPU之后，**真正开始执行run()方法的线程执行体时**，意味着该线程就已经处于**运行状态**。需要注意的是，**对于单处理器，一个时刻只能有一个线程处于运行状态。**
对于抢占式策略的系统来说，系统会给每个线程一小段时间处理各自的任务。时间用完之后，系统负责夺回线程占用的资源。下一段时间里，系统会根据一定规则，再次进行调度。

**运行状态转变为就绪状态**的情形：
- 线程失去处理器资源。线程不一定完整执行的，执行到一半，说不定就被别的线程抢走了。
- 线程调用yield()，暂时暂停当前线程，让系统的线程调度器重新调度一次，它自己完全有可能再次运行。

yield方法的官方解释：
> A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint. 

提示调度程序，当前线程愿意放弃当前对处理器的使用。这时，**当前线程将会被置为就绪状态**，和其他线程一样等待调度，这时候根据不同**优先级**决定的**概率**，当前线程完全有可能再次抢到处理器资源。
## 阻塞状态
处于**阻塞状态**的线程将会放弃所占用的资源，这时其他线程将会获得执行机会，同样地，将要执行的线程取决于JVM调度。

导致线程阻塞的几种情况：

- 线程调用`sleep()`方法，阻塞一段时间。
- 线程调用**阻塞式IO**方法，方法返回之前，线程会被阻塞。
- 试图取得其他线程正持有的同步监视器。
- 处于**等待唤醒**状态的线程会阻塞。

sleep()和yield()的不同之处：

- sleep()方法会**使线程转入阻塞状态**，时间到了之后才会转入就绪状态。而yield()方法不会将线程转入阻塞状态，而是强制线程进入就绪状态。
- 使用sleep()方法**需要处理异常**，而yield()不用。

## 消亡状态
即**线程的终止**，表示线程已经执行完毕。前面已经说了，已经消亡的线程不能通过start再次唤醒。

- run()和call()线程执行体中顺利执行完毕，**线程正常终止**。
- 线程抛出一个没有捕获的Exception或Error。

需要注意的是：主线成和子线程互不影响，子线程并不会因为主线程结束就结束。

---

本文作为个人学习笔记，仍停留在比较浅显的层面，还需要大量的实践去感悟并发编程的奥义


参考资料：《JAVA并发编程实践》、《疯狂Java讲义》