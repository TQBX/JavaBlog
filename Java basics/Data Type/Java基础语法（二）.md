[TOC]



# Java基础语法（二）

> 承接上篇，谈到不同变量装载着不同数据类型的数据，那么Java支持的数据类型有哪些呢，本篇做一点小小的探究。

---

## 一、强类型语言

> Java就是一种**强类型**的语言，包含着以下含义：

- <u>所有的变量必须在声明之后才能使用</u>，不能用的不明不白或者用得很随意。
- <u>指定类型的变量只能结束类型与之匹配的值</u>，很好理解，种瓜得瓜，种豆得豆，这才正常。

## 二、数据类型分类

> Java数据类型分为**基本数据类型**和**引用数据类型**两大类。

### 1、基本数据类型

> 字符类型其实归于整数类型，是**无符号整数类型**。但鉴于他和其他兄弟姐妹有点不一样，所以把他单独拎出来，基本数据类型变分成了四类。

#### 整数类型

> 1字节 = 8位

##### 四种类型所占内存空间：

- `byte`:在内存中占1个字节，也就是8位，表数范围：-2^7 ~2^7-1
- `short`:在内存中占2个字节，也就是16位，表数范围：-2^{15} ~2^{15}-1
- `int`: 在内存中占4个字节，也就是32位，表数范围：-2^{31} ~2^{31}-1
- `long`: 在内存中占8个字节，也就是64位，表数范围：-2^{63}~2^{63}-1

##### 注意事项：

- 如果将一个比较小的整数（当然比byte和short要小）赋给byte和short变量，系统会自动把他们当作这两种类型处理。
- 如果把上面那个小的整数赋给long变量，系统首先会把数值当作int处理，int类型之后自动转换成long类型。
- 如果使用一个较大的整数值（反正比int大），系统则不会自动把他当作long处理，如果想的话，就在后面加上L或者l吧，推荐L。

##### 整数的表示方式：

- 二进制：以0b或者0B开头。

- 八进制：以0开头。

- 十进制：懂得都懂。

- 十六进制：以0x或者0X开头。

	> 所有的数字在计算机底层都是以二进制的形式存在的，且以补码的形式保存所有的整数。
	>
	> - 正数的补码和原码完全相同。
	> - **负数最高位符号位不变，其他去反，整体加1，就是补码。**

- 整数值默认是int类型，占32位，且最高位为符号位。最后加上L之后，转换成long类型，占64位。

- 由于最高位符号位的存在，当强制转换时，可能会导致数据产生偏差。

#### 字符类型

> 字符型的值要用单引号`' '`,**一定是单引号**！！！Java使用16位的Unicode字符集作为编码方式，所以支持任何语言。
>
> 定义方式 `char varName;`

##### 字符型表现形式：

- 直接通过单个字符表示。如`A`,`0`等。
- 通过转义字符表示，如`\t`,`\r`,`\n`等。如果想输出特殊的字符，则需要加上`\`再次转义，例如`"d:\\numert".`
- 通过Unicode值表示，如`\uXXXX`,XXXX代表一个16进制整数。

#### 浮点类型

##### 两种类型所占内存空间：

- `float`:单精度浮点数，占4个字节，32位，第一位符号位，后8位为指数，后23位为尾数。
- `double`:双精度浮点数，占8个字节，64位，第一位符号位，后11位指数，后52位尾数。

##### 注意事项：

- **默认类型为double类型**，想用float类型处理，需要在后面i爱上f或者F。
- 浮点数需要加上小数点，不然当成int处理就懵逼了。
- 只有浮点数类型的数值才能用科学记数法：3.14e2表示3.14*10^2

##### 关键的无穷：

> Java为浮点数运算提供了三个特殊的浮点数值：正无穷大，负无穷大和非数。

- 正无穷大：正数除以0得到->`POSITIVE_INFINITY`.
- 负无穷大：负数除以0得到->`NEGATIVE_INFINITY`.
- 非数：0.0处以0.0或者对负数开方得到->`NaN`
- **注意**：如果整数值除以0，会报错。

> 如果数值中位数过多，不论整数还是浮点数都可以通过下划线分割：`0b0000_0000_0010_1111`

#### 布尔类型

- 只有boolean类型，表示逻辑“真”或“假”。
- <u>Java中不能用0或者非0表示true或者false。</u>
- 其他的基本数据类型也不能转换成boolean类型。
- boolean类型值和字符串进行连接时，会自动转换为字符串类型。

### 2、引用数据类型

> 包括类、接口和数组类型，以及特殊的null类型。

- 之后将会提到。

## 三、基本类型转换

### 自动类型转换

- 自动也就是系统支持的，<u>将表数范围小的数值直接赋给表数较大的变量</u>，就可以实现自动类型转换。
- 其实很好理解，类似于数学里的集合，A比B大，C可以存在B里面，当然就可以存在A里面，而且空间还变大了呢，舒服。
- 任何基本类型的值和字符串进行连接运算时，都会自动转换成字符串类型，虽然字符串为引用类型。
- 下图为自动类型转换图：

![](https://img2018.cnblogs.com/blog/1771072/201911/1771072-20191110144346123-957714335.jpg)

### 强制类型转换

- 相反，自动类型转换图按反方向转换的话，就需要强制转换，格式：`（目标类型）值`。
- 显然，和自动类型相比，强制类型转换是有风险的，可能会溢出，造成信息丢失。

## 四、表达式类型的自动提升

> 当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型会发生自动提升。

- byte、short和char类型将自动提升为int类型。
- **提升到最高等级操作数同样的类型**。具体查看转换图，右边比左边高。

- 易发生错误：

	```java
	//定义一个short型变量
	short value = 4;
	//右边数值2为int型，所以右边自动转换为int类型，而左边是short，不匹配，错误！
	value = value -2;
	```

	```java
	int val = 3;
	//右边两个操作数都是int型，尽管不能除尽，但仍然得到int型数，输出int值7
	int value = 23/val;
	```

	```java
	System.out.println("hello"+'a'+10);//输出字符串helloa10
	System.out.println('a'+10+"hello");//‘a'自动提升至int类型，得出107，之后与字符串拼接，自动转换为字符串类型，输出字符串107hello
	```

	