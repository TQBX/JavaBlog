[toc]

基于《深入理解Java虚拟机》第三版

# Java内存区域之运行时数据区域

## 1. 程序计数器

Program Counter Register：当前线程所执行的字节码的行号指示器。

【JVM多线程的实现】：**线程轮流切换，分配处理器执行的时间**。

- 保证线程切换后能恢复到正确的执行位置-->每个线程拥有独立的程序计数器。

【针对方法不同】：

- Java方法：记录正在执行的虚拟机字节码指令的地址。
- 本地Native方法：计数器值为空。

## 2. Java虚拟机栈

Java Virtual Machine Stack：线程私有，生命周期与线程相同。

描述的是Java方法：每个方法被执行的时候，JVM回同步创建一个栈帧，用于存放以下信息：

- 局部变量表、操作数栈、动态连接、方法出口等信息。

每个方法被调用至执行完毕的过程，对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

> 我们通常说的栈，其实指的就是虚拟机栈，或者是虚拟机栈中的局部变量表。

### 局部变量表

- 所需的内存空间**在编译期间完成分配**，在方法运行期间就不会再改变局部变量表的大小。
- 存放编译期可知的JVM基本数据类型，引用类型和returnAddress类型，存储空间为Slot，局部变量槽。

### 异常情况

- 线程请求的栈深度大于虚拟机所允许的深度：StackOverflowError。
- JVM栈容量可以动态扩展，当栈扩展时无法申请足够的内存：OutOfMemoryError。

## 3. 本地方法栈

和虚拟机栈差不多，针对本地Native方法执行服务。

同样也存在StackOverflowError和OutOfMemoryError异常。

## 4. Java堆 

**被所有线程共享**，在虚拟机启动的时候创建，用以存放对象实例。

### 垃圾收集管理

是**垃圾收集器管理的内存区域**，也被称为GC堆（Garbage Collected Heap）。

大部分基于**分代收集理论设计**。

从分配内存角度看，所有线程共享的Java heap中可以划分出线程私有的分配缓冲区，提升对象分配效率。

---

Java堆可以处理物理不连续的内存空间中，但逻辑上需要连续。

当前主流的Java虚拟机按照可扩展来实现，通过**-Xmx和-Xms**设定。

### 异常情况

Java堆没有内存完成实例分配，堆无法再扩展时：OOM。

## 5. 方法区

与Java堆一样，**各个线程共享**，用以存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

JDK8之前，方法区是使用收集器的分代设计的永久代实现，之后采用本地内存来实现方法区。

如果方法区无法满足新的内存分配需求：OOM。

## 6. 运行时常量池

Runtime Constant Pool，是**方法区的一部分**。

Class文件【类的版本，字段，方法，接口等描述信息+常量池表】中用以存放编译期生成的字面量与符号引用的内容，将在类加载后存放到方法区的**运行时常量池**中。

### 与Class文件常量池的区别

- JVM对Class文件常量池的格式有严格规定，但对运行式常量池则没有要求。
- 运行时常量池具有动态性，即不要求常量一定只有编译器才产生。

