基于《深入理解Java虚拟机》第三版

# Java内存区域

## 运行时数据区域

### 1. 程序计数器

Program Counter Register：当前线程所执行的字节码的行号指示器。

JVM多线程的实现：线程轮流切换，分配处理器执行的时间。

- 保证线程切换后能恢复到正确的执行位置-->每个线程拥有独立的程序计数器。

针对方法不同：

- Java方法：记录正在执行的虚拟机字节码指令的地址。
- 本地Native方法：计数器值为空。

### 2. Java虚拟机栈

Java Virtual Machine Stack：线程私有，生命周期与线程相同。

描述的是Java方法：每个方法被执行的时候，JVM回同步创建一个栈帧，用于存放以下信息：

- 局部变量表、操作数栈、动态连接、方法出口等信息。

每个方法被调用至执行完毕的过程，对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

> 我们通常说的栈，其实指的就是虚拟机栈，或者是虚拟机栈中的局部变量表。

#### 局部变量表

- 所需的内存空间在编译期间完成分配，在方法运行期间就不会再改变局部变量表的大小。
- 存放编译期可知的JVM基本数据类型，引用类型和returnAddress类型，存储空间为Slot，局部变量槽。

#### 异常情况

- 线程请求的栈深度大于虚拟机锁允许的深度：StackOverflowError。
- JVM栈容量可以动态扩展，当栈扩展时无法申请足够的内存：OutOfMemoryError。

### 3. 本地方法栈

和虚拟机栈差不多，针对本地Native方法执行服务。

同样也存在StackOverflowError和OutOfMemoryError异常。

### 4. Java堆 

被所有线程共享，在虚拟机启动的时候创建，用以存放对象实例。

#### 垃圾收集管理

是垃圾收集器管理的内存区域，也被称为GC堆（Garbage Collected Heap）。

大部分基于分代收集理论设计。

从分配内存角度看，所有线程共享的Java heap中可以划分出线程私有的分配缓冲区，提升对象分配效率。

---

Java堆可以处理物理不连续的内存空间中，但逻辑上需要连续。

当前主流的Java虚拟机按照可扩展来实现，通过-Xmx和-Xms设定。

#### 异常情况

Java堆没有内存完成实例分配，堆无法再扩展时：OOM。

### 5. 方法区

### 6. 运行时常量池

### 7. 直接内存