# 题目描述

我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**示例:**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**说明:** 

1. `1` 是丑数。
2. `n` **不超过**1690。

# 解题思路

有一种比较好理解的做法：三指针。

我们知道，丑数的特点是：丑数只包含2，3，5的因子，一个丑数可以看作是一个较小丑数×因子。

如何得到丑数呢？很简单，此时第一个丑数为1，那么下一个丑数，要么是2，要么是3，要么是5。假设有三个数组：

```java
a --> [1*2,2*2,3*2,4*2...]
b --> [1*3,2*3,3*3,4*3...]
c --> [1*5,2*5,3*5,4*5...]
```

最终的丑数序列其实是a,b,c**三个有序数组的无重复元素合并**，那么如何合并？利用**三指针**。

首先创建新数组ugly，并规定ugly[i]代表第i+1个丑数，也就是初始化ugly[0] = 1。

我们可以让每个数字各自维护一个指针，三个都初始化为0，每次分别从三个数组中取出，每次将最小的丑数置入对应的位置，相应的数组指针++。

返回值ugly[n-1]就是第n个丑数。

# 代码实现

```java
    public int nthUglyNumber(int n) {
        //初始化
        int a = 0,b = 0,c = 0;
        int[]ugly = new int[n];
        //初始状态定义
        ugly[0] = 1;
        for(int i = 1;i<n;i++){
            int n2 = ugly[a]*2;
            int n3 = ugly[b]*3;
            int n5 = ugly[c]*5;
            ugly[i] = Math.min(Math.min(n2,n3),n5);
            //分别用三个if,过滤重复解的情况 
            if(ugly[i] == n2) a++;
            if(ugly[i] == n3) b++;
            if(ugly[i] == n5) c++;
        }

        System.out.println(Arrays.toString(ugly));
        return ugly[n-1];
    }
```

# 复杂度分析

时间复杂度：O(N)：遍历N=n次得到列表。

空间复杂度：O(N)：需要额外N=n长度的数组空间。