![image-20200430171524645](C:\Users\13327\AppData\Roaming\Typora\typora-user-images\image-20200430171524645.png)

之前写过一篇Spring面向切面编程的具体操作：三种方式配置通知，当然也只是停留在操作层面，今天回头看这个知识点的时候，发现自己的理解更加深刻，故在此做一点小小的总结。

AOP面向切面编程是spring的核心之一，它的一些术语还是比较抽象的，至少初始的时候我是这么觉得的，但慢慢接触了一些设计思想，如代理模式创建实现相同接口的代理对象，以增强指定方法的思想之后，就渐渐理解其中的精妙，当然，理解还是不能完全理解的，只能说慢慢探索，日益精进。

# 一、简单案例的理解

面向切面编程的思想被广泛应用一定有他的道理，一定是因为它的出现解决了某些繁杂的类似于搬砖似的工作。

我们以一个简单案例作为切入，请暂时不要在意其中逻辑，暂时以打印日志信息作为事务控制：

首先，我们定义一个账户接口AccountService，里面包含一些基本的增删改方法，并创建一个实现类AccountServiceImpl实现之，暂且以打印信息模拟数据库操作。

```java
@Service("accountService")
public class AccountServiceImpl implements AccountService {
    public void saveAccount() {
        System.out.println("==> 正常业务:AccountServiceImpl的saveAccount方法正常执行");
    }
    public void updateAccount(int i) {
        System.out.println("==> 正常业务:AccountServiceImpl的updateAccount方法正常执行");
    }
    public int deleteAccount() {
        System.out.println("==> 正常业务:AccountServiceImpl的deleteAccount方法正常执行");
        return 10;
    }
}
```

>  需求：在每个方法执行前后都打印日志信息，如果发生异常，打印异常信息。

呃，需求还是很好实现的，随便一想就有俩可以实现这个简单的需求：

- 直接在方法里面打印信息嘛，所有方法都写上一遍，不怕累，但日志代码大量侵入正常业务功能模块，存在大量耦合，显然不可取。
- 使用动态代理技术，基于JDK的动态代理技术，创建出与被代理对象实现相同接口的代理对象，在反射调用方法前后对方法进行增强，比如打印必要的日志信息。

于是我们果断采用动态代理的技术，对需求进行实现，并进行了测试：

```java
public class aopTest {
    public static void main(String[] args) {
        //获取容器
        ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");
        //获取对象
        final AccountService as = ac.getBean(AccountService.class);
        AccountService asProxy = (AccountService)Proxy.newProxyInstance(as.getClass().getClassLoader(), as.getClass().getInterfaces(), new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Object value = null;
                //获取方法名
                String name = method.getName();
                try {
                    System.out.println(name+"方法 ==>即将执行...");
                    value = method.invoke(as, args);
                    System.out.println(name+"方法 ==>环绕返回通知... 返回结果 ==>"+value);
                } catch (Throwable e) {
                    System.out.println(name+"方法 ==>环绕异常通知... 异常信息 ==>"+e);
                } finally {
                    System.out.println(name+"方法 ==>最终执行完毕...");
                }
                return value;
            }
        });
        //执行方法
        asProxy.deleteAccount();
        System.out.println("================");
        asProxy.saveAccount();
    }
}

```

![image-20200430214826712](C:\Users\13327\AppData\Roaming\Typora\typora-user-images\image-20200430214826712.png)

可以发现动态代理可以实现我们的需求，但JDK的动态代理只能基于接口进行，如果要基于实现类，可以利用第三方库cglib实现，在此就不赘述了。

ok，说到这，我们成功地使日志代码动态地在目标业务方法的前后执行，我们的业务代码仅仅只需要关注业务自身逻辑，而日志信息，事务控制等代码转移至切面中即可，其中的合理性也是显而易见的。

![image-20200430224419399](C:\Users\13327\AppData\Roaming\Typora\typora-user-images\image-20200430224419399.png)

# 二、AOP术语学习

切面

切入点

连接点

通知

