[toc]
# Java多态之向下转型

> 往期回顾：我们学习了向上转型和动态绑定的概念，可以知道在继承关系中，将一个子类对象赋值给父类的引用变量，调用父类的方法，在实际运行时，就可以根据子类中重写的方法执行不同的操作。其中有一个弊端，就是在向上转型的过程中，其实丢失了一部分子类特有的功能，毕竟它只允许调用父类中的方法。那么，<u>如何在这时调用子类中的方法呢</u>，这时就需要与向上转型相对应的方法，就是所谓的：**向下转型**。

向上转型是自动就能完成的，向下转型则需要**强制类型转换**。
## 强制类型转换
我们前面提到过基本数据类型的强制转换，可以查看之前的文章：[基本数据类型转换](
https://www.cnblogs.com/summerday152/p/11830161.html#%E4%B8%89%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2)
引用变量的强制类型转换与基本数据类型类似，都需要用到**类型转换运算符**：`()`。

```java
//将变量强制转换为type类型
type p = (type)变量
```
**特别注意**：
- 基本数据类型中，数值类型和布尔类型无法进行类型转换。
```java
//错误！
boolean boo = true;
int in = (int)boo;
```
- 不在继承关系中的两个类型无法进行强制类型转换。
```java
//假设Person类和Dog类不具有继承关系，则下面会出错
Person p = new Person();
Dog dog = (Dog)p;
```
- 就算在继承关系中，也不能把父类的实例转换成子类类型。（也就是说，引用变量必须编译时是父类类型，运行时是子类类型才可以）注意，编译时是不会报错的，只有运行时才会报错。
```java
//假设Student继承于Person类
//编译时正常，运行时出错
Person p = new Person();
Student s = (Student)p;
```

## instanceof
将一个父类引用赋给一个子类变量时，必须经过强制类型转换。如果出现强制类型转换双方不匹配的话，运行时通过`(RTTI 
Run-Time Type Identification)`，即**运行时类型识别**，检查并返回`ClassCastException`，即**类型转换异常**。

为了避免这一尴尬的问题发生，我们可以用`instanceof`运算符来检查，确保程序的健壮性。
`instance`是实例的意思，可想而知，`instanceof`表示**判断前面的对象是否是后面的类，或者子类，实现类的实例**。如果是就返回true，否则就false。

```java
[引用类型变量] instanceof [类（接口）]
```
从上面诸多错误例子中随便举一个：
```java
//在强制类型转换前加上instanceof语句判断
Person p = new Person();
if (p instanceof Student) {
Student s = ((Student) p);
}
```
这时，if判断语句中为false，里面自然无法执行，也就避免程序报错，保证了程序的健壮性。